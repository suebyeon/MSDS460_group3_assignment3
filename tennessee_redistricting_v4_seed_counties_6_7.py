# -*- coding: utf-8 -*-
"""Tennessee_Redistricting_v4_seed_counties_6_7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hZ7x_yDx77SryQm28CJnEcuL1jl6ZCDV

Making it a smaller problem.

I started by manually forcing counties to certain districts by looking at a heatmap of population and forcing large counties that were spread across the state to different districts. I got some districts that were contiguous doing this, but a lot that still had unconnected island pairs of counties. I kept adding counties that I forced to specific districts and eventually added all of them by adding counties to a district until I got to a combined pop around the target number.

With the rough manual assignment as a starting point

I also changed filtered_list back to pairs_list for some parts. Not positive, but I think when we used filtered_list (the list of counties that are adjacent) in the objective, it wasn't punishing solutions that had disparate counties in the same district since there was no distance term to add.

Packages
"""

#!pip install pulp

import pandas as pd
import os
import re
from pulp import LpProblem, LpVariable, LpMinimize, lpSum, LpBinary

"""Load in data"""

# from google.colab import drive
# drive.mount('/content/drive')

file_path = ''  # for running locally

#julia filepath
#file_path = '/content/drive/My Drive/MSDS 460/Tennessee Redistricting/data/'

# paul filepath
#file_path = '/content/drive/My Drive/shared_folders/MSDS 460/Tennessee Redistricting/data/'

#graham filepath
#file_path = "/content/drive/My Drive/"

county_pop_data = pd.read_csv(file_path + 'tennessee_county_pop_data.csv')
county_pop_data_with_white = pd.read_csv(file_path + 'tennessee_county_pop_data_with_white_pop.csv')
counties_no_district = pd.read_csv(file_path + 'tennessee_data_counties_without_a_district.csv')

# new
# change county name from , Tennessee to , TN to match other lists

counties_no_district['name'] = counties_no_district['name'].str.replace(', Tennessee', ', TN')
counties_no_district.head()

"""Adjacency

File paths:

We may need to figure out how to change between file paths since people may have it in different spots
"""

# new

# I deleted the Davidson and Shelby chunks from the adjacenty text doc, but they were stil listed as sub-counties under other counties.
# This caused key errors further down where we iterate through neighbors and it looked for variables for Davison and Shelby that didn't exist
# I went in and deleted both counties in  everywhere in the adjacency text and saved that file as adjacency_tennessee_shelby_davidson_counties_removed_from_all.txt in the same folder

# this uses the path above so no need to uncomment/change it here
adjacency_file_path = file_path + 'adjacency_tennessee_shelby_davidson_counties_removed_from_all.txt'

#changed all the filepaths below to the _from_all version just in case

#julia filepath
#adjacency_file_path = "/content/drive/My Drive/adjacency_tennessee_shelby_davidson_counties_removed_from_all.txt"
#adjacency_file_path = "/content/drive/My Drive/MSDS 460/Tennessee Redistricting/data/adjacency_tennessee_shelby_davidson_counties_removed_from_all.txt"

#graham filepath
#adjacency_file_path = "/content/drive/My Drive/adjacency_tennessee_shelby_davidson_counties_removed_from_all.txt"

# paul path to adjacency file
#adjacency_file_path = "/content/drive/My Drive/shared_folders/MSDS 460/Tennessee Redistricting/data/adjacency_tennessee_shelby_davidson_counties_removed_from_all.txt"

def parse_county_borders(adjacency_file_path):
  county_borders = {}
  with open(adjacency_file_path, 'r', encoding='utf-8') as file:
      current_county = None

      for line in file:
          line = line.strip()
          #print(line) #Used for testing we can delete this line
          if not line:
              continue

          parts = line.split('\t')
          #print(parts) #Used for testing we can delete this line
          #print(len(parts)) #Used for testing we can delete this line

          county_name = parts[0].strip('"')
          #print(county_name) #Used for testing we can delete this line

          x = re.search("TN$", county_name) #Txt file included border counties from other states this looks for 'TN'
          #print(x) #Used for testing we can delete this line

          if x:   #If the county is in TN proceed, otherwise skip
            if len(parts) > 2:  # This is a new county (length equals 4 when it is a new county)
                current_county = county_name
                county_borders[current_county] = set()
            elif current_county and county_name != current_county:  # new for some reason some counties like Meigs listed themselves as adjacent to themselves - see cell below-- which would mess up the adjacency constraints
                county_borders[current_county].add(county_name)

      return county_borders

# new added -- and county_name != current_county: --  above
# for some reason some counties like Meigs listed themselves as adjacent to themselves - see cell below-- which would mess up the adjacency constraints

# this was using the old dictionary

# this
# county_dict['Meigs County, TN']

# output this
# {'Hamilton County, TN',
#  'McMinn County, TN',
#  'Meigs County, TN',   <---
#  'Rhea County, TN',
#  'Roane County, TN'}

county_dict = parse_county_borders(adjacency_file_path)
print(len(county_dict))
first_item = list(county_dict.items())[0]
print(first_item)
last_item = list(county_dict.items())[92]
# print(last_item)

county_dict['Meigs County, TN']

"""Setting up variables"""



# new changing so that the list includes the , TN to match county_dict

county_list = counties_no_district["name"].tolist()

district_list = list(range(1,8))

county_list[1:5]

total_population = county_pop_data["population"].sum()
populations = dict(zip(counties_no_district["name"], counties_no_district["population"]))
populations['Meigs County, TN']

#populations

target_population = total_population / 9
print(target_population)

# change pop limits to 0.7 and 1.3 to match the criteria we used for making counties their own districts

pop_min = 0.7 * target_population
pop_max = 1.3 * target_population

#print(county_dict.items())

print(county_dict['Anderson County, TN'])

# new
# changed to for neighbor in neighbors

county_neighbors = {}
for county, neighbors in county_dict.items():
  county_name = county.split(',')[0]
  #print(county_name)
  neighbor_names = [neighbor.split(',')[0] for neighbor in neighbors]
  #print(neighbor_names)
  county_neighbors[county_name] = neighbor_names

#county_neighbors

county_neighbors['Anderson County']

county_list[0]

# Define Model
model = LpProblem("Tennessee_Redistricting", LpMinimize)

# Decision Varaible
x = {(i,j):LpVariable(f"x_{i}_{j}", cat=LpBinary) for i in county_list for j in district_list}

x['Meigs County, TN', 1]

########## distance stuff paul

#!pip install pyproj

# data from https://www.census.gov/geographies/reference-files/time-series/geo/gazetteer-files.2020.html#list-tab-264479560
# search for counties on the page
# i added the lat long csv to the same data folder

df_lat_longs = pd.read_csv(file_path + 'county_lat_longs_without_davidson_or_shelby.csv')

df_lat_longs.head()

df_lat_longs['name'] = df_lat_longs['name'] + ', TN'
df_lat_longs.head()

# this whole section through the cell with the comment # distance script end

# could be a separete script that spits out a county_county_distance-between csv but i didnt have time to separate it out

# from provided distance calculation code

import math
from math import pi, pow, sin, cos, asin, sqrt, floor
from scipy import stats
import numpy as np
from pyproj import Proj

def degrees_to_radians(x):
     return((pi/180)*x)

def lon_lat_distance_miles(lon_a,lat_a,lon_b,lat_b):
    radius_of_earth = 24872/(2*pi)
    c = sin((degrees_to_radians(lat_a) - \
    degrees_to_radians(lat_b))/2)**2 + \
    cos(degrees_to_radians(lat_a)) * \
    cos(degrees_to_radians(lat_b)) * \
    sin((degrees_to_radians(lon_a) - \
    degrees_to_radians(lon_b))/2)**2
    return(2 * radius_of_earth * (asin(sqrt(c))))

def lon_lat_distance_meters (lon_a,lat_a,lon_b,lat_b):
    return(lon_lat_distance_miles(lon_a,lat_a,lon_b,lat_b) * 1609.34)

# UTM zone may be computed directly from the list of longitude values
def findZone(listOfLon):
    zones = [ ((floor((long + 180)/6) ) % 60) + 1 for long in listOfLon]
    zone = stats.mode(zones, keepdims = False)[0].astype(int)
    return(zone.item())

df_lat_longs.head()

len(df_lat_longs)

#print(county_list)
len(county_list)

# test the distance function

print("distance between anderson and bedford in miles: ",lon_lat_distance_miles(-84.195418 ,36.116731,-86.458294,35.513660))

# im sure there's a much better way to do this, but i needed a df with all the county pairs and the distacne between the two as the columns
# the next couple blocks turn the county / long / lat df into a dictionary so i can pull the lat/long data for each county and make a new df with lat longs for both pairs


df_lat_longs['name_for_index'] = df_lat_longs['name']
df_lat_longs.head()

# https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.set_index.html

df_lat_longs.set_index('name_for_index', inplace=True)
df_lat_longs.head()

# https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_dict.html

lat_long_dict = df_lat_longs.to_dict('index')

# this makes a list of every combination of county pairs

# https://stackoverflow.com/questions/36242735/combination-of-values-in-pandas-data-frame

import itertools
pairs_list = list(itertools.combinations(df_lat_longs['name'], 2))
len(pairs_list)

print(pairs_list[0:4])

#NEW
#Reduce pairs_list to only pairs where counties touch using county_dict
filtered_pairs = [
    (county1, county2) for county1, county2 in pairs_list
    if (county1 in county_dict and county2 in county_dict[county1])
]

#print(filtered_pairs)

for i, j in filtered_pairs:
  if i == 'Anderson County':
    print(j)

for i, j in filtered_pairs:
  if i == 'Knox County':
    print(j)

#NEW
len(filtered_pairs)

#SKIP FOR NEW VERSION - Graham
# this takes the pairs list and turns it into a dataframe where columns 1 and 2 are all all the possible pairs of counties
#------------------------------------------------------------------------------------
#df_pairs = pd.DataFrame(pairs_list,  columns = ['county1', 'county2'])
#df_pairs.head()

#NEW
# this takes the pairs list and turns it into a dataframe where columns 1 and 2 are all the pairs of counties that touch

df_pairs = pd.DataFrame(pairs_list,  columns = ['county1', 'county2'])
df_pairs.head()

#SKIP FOR NEW VERSION - Graham
#Nothing changed in this code block, but df_pairs is different so save for old output
#------------------------------------------------------------------------------------
# adds the lat long info for each county to the df with the county pair columns

# https://www.w3schools.com/python/pandas/ref_df_iterrows.asp

import numpy as np

for index, row in df_pairs.iterrows():
    county1 = row['county1']
    #print(county1)
    county2 = row['county2']
    long1 = lat_long_dict[f'{county1}']['long']
    lat1 = lat_long_dict[f'{county1}']['lat']
    long2 = lat_long_dict[f'{county2}']['long']
    lat2 = lat_long_dict[f'{county2}']['lat']
    #print(long_1)
    df_pairs.loc[index,'long1'] = long1
    df_pairs.loc[index,'lat1'] = lat1
    df_pairs.loc[index,'long2'] = long2
    df_pairs.loc[index,'lat2'] = lat2

df_pairs.head()

#SKIP FOR NEW VERSION - Graham
#Nothing changed in this code block, but df_pairs is different so save for old output
#------------------------------------------------------------------------------------
# adds distance between the pairs of counties using the miles distance function

# https://www.geeksforgeeks.org/create-a-new-column-in-pandas-dataframe-based-on-the-existing-columns/

# df['Discounted_Price'] = df.apply(lambda row: row.Cost -
#                                   (row.Cost * 0.1), axis = 1)

df_pairs['distace_between'] = df_pairs.apply(lambda row: lon_lat_distance_miles(row.long1, row.lat1, row.long2, row.lat2), axis = 1)

df_pairs.head()

len(df_pairs)

# anderson and bedford should match the distance in df_pairs

print("distance between anderson and bedford in miles: ",lon_lat_distance_miles(-84.195418 ,36.116731,-86.458294,35.513660))

# I added below to check new version - Graham
print("distance between anderson and campbell in miles: ",lon_lat_distance_miles(-84.195418 ,36.116731,-84.159249,36.401592))

#SKIP FOR NEW VERSION - Graham
#Nothing changed in this code block, but saved for old output
#------------------------------------------------------------------------------------
# necking down to just distance between

df_county_pairs_and_distances = df_pairs[['county1', 'county2', 'distace_between']]
df_county_pairs_and_distances.head()


# distance script end

len(df_county_pairs_and_distances)



# notes on distance variables and constraints

# we have variables for each county-district pair e.g. x_Anderson_1 = 1 if Anderson is in district 1

# need to make a variable for each county-county-district set
# e.g. Anderson_Bedford_1 = 1 if Anderson and Bedford are in district 1
# use LpVariable.dicts?  https://www.youtube.com/watch?v=qa4trkLfvwQ

# need to make costs that are the distance between county pairs
# e.g. Anderson_Bedford = 133.4


# need to add constraintes that make the variable for each pair = 1 if both counties
# are in the same district and = 0 otherwise

# y_i_j_d can only be 0 or since since it is binary

# constraint

#1  y_i_j_d (county i, county j, district d) <= Xid

        # if Xid =1 (county i is in district d), then y_i_j_d can be 1 or 0
        # if Xid =0 (county i is not in district d), then y_i_j_d must = 0

#2  y_i_j_d (county i, county j, district d) <= Xjd

        # if Xjd =1 (county j is in district d), then y_i_j_d can be 1 or 0
        # if Xjd =0 (county j is not in district d), then y_i_j_d must = 0

#3  y_i_j_d (county i, county j, district d) >= Xid + Xjd - 1

        # if Xid = 1 (county i is in district d) and Xjd =0 (county j is not in district d),
            #then (Xid + Xjd - 1) = 1 + 0 -1 = 0 so y_i_j_d >= 0 can be 1 or 0
        # if Xid = 0 (county i is not in district d) and Xjd = 1 (county j is in district d),
            #then (Xid + Xjd - 1) = 0 + 1 -1 = 0 so y_i_j_d >= 0 can be 1 or 0
        # if both Xid = 1 and Xjd = 1 (both i and j are in district d),
            #then (Xid + Xjd - 1) = 1 + 1 -1 = 1 so y_i_j_d >= 1 must be 1

#NEW - uses filtered_pairs
# county-county-district variables

district_list = list(range(1,8))

# x is a dictionary of variables that cpntains the every county-county-district combination
# as the key and has the variable name y_county1_county_2_district as the value

# each variable eventually needs to = 1 only when both counties are in the same district

y = {(i, j, d): LpVariable(f"y_{i}_{j}_{d}", cat=LpBinary) for (i, j) in pairs_list for d in district_list}

#print(y)

len(pairs_list)

#NEW
# cost dict for each county-county-pair

# each county-county pair distance gets multiplied by each matching county-county-district variable
# e.g. a max of one of y_Anderson_Bedford_1, y_Anderson_Bedford_2... will = 1 since those
# variables only = 1 if both counties are in the same district
# if they're not, all of them will = 0
# since only a max of one will = 1, we can multiply all of them by the county-county distance
# and it will only be included in the sum if they happen to fall in the same county

county_county_distance_dict = {}

# https://www.w3schools.com/python/pandas/ref_df_iterrows.asp

for index, row in df_county_pairs_and_distances.iterrows():
    county1 = row.county1
    county2 = row.county2
    distance = row.distace_between
    county_county_distance_dict[(county1, county2)] = distance

#print(county_county_distance_dict)

"""Optimization"""

#SKIP FOR NEW VERSION - Graham
#Replacing pairs_list with filtered_pairs
#------------------------------------------------------------------------------------
# Constraint 1: Each county must be part of one district
for i in county_list:
    model += lpSum(x[i, j] for j in district_list) == 1

# Constraint 2: Each district must approximately the same population

for j in district_list:
  model += lpSum(populations[i] * x[i, j]  for i in county_list) >= pop_min
  model += lpSum(populations[i] * x[i, j] for i in county_list) <= pop_max

district_list[0]

county_list[0]

county_dict['Anderson County, TN']

x['Anderson County, TN', 1]

county_neighbors['Anderson County']



# counties near high populations according to heatmap  https://www.someka.net/blog/tennessee-county-map/

# Madison
# Dickson
# Rutherford
# Cumberland
# Hamilton
# Knox
# Washington

# adding some specific constraints for border counties or counties that touch <= 3 other counties
# these make sure that corner counties for example don't get isolated

for j in district_list:
    model += 2 * x['Lake County, TN', j] <= x['Obion County, TN', j] + x['Dyer County, TN', j]
    model += 3 * x['McNairy County, TN', j] <= x['Hardeman County, TN', j] + x['Chester County, TN', j] + x['Hardin County, TN', j]
    model += 3 * x['Polk County, TN', j] <= x['Bradley County, TN', j] + x['McMinn County, TN', j] + x['Monroe County, TN', j]
    model += 3 * x['Unicoi County, TN', j] <= x['Greene County, TN', j] + x['Washington County, TN', j] + x['Carter County, TN', j]
    model += 2 * x['Johnson County, TN', j] <= x['Carter County, TN', j] + x['Sullivan County, TN', j]
    #model += 3 * x['Hancock County, TN', j] <= x['Hawkins County, TN', j] + x['Grainger County, TN', j] + x['Claiborne County, TN', j]
    #model += 3 * x['Pickett County, TN', j] <= x['Scott County, TN', j] + x['Fentress County, TN', j] + x['Clay County, TN', j]
    #model += 3 * x['Stewart County, TN', j] <= x['Henry County, TN', j] + x['Houston County, TN', j] + x['Montgomery County, TN', j]

    model += 3 * x['Tipton County, TN', j] <= x['Lauderdale County, TN', j] + x['Haywood County, TN', j] + x['Fayette County, TN', j]
    model += 3 * x['Fayette County, TN', j] <= x['Tipton County, TN', j] + x['Haywood County, TN', j] + x['Hardeman County, TN', j]
    model += 6 * x['Haywood County, TN', j] <= x['Tipton County, TN', j] + x['Fayette County, TN', j] + x['Lauderdale County, TN', j] + x['Crockett County, TN', j]+ x['Madison County, TN', j] + x['Hardeman County, TN', j]

x['Madison County, TN', 1]

district_list

len(county_list)

# I manually grouped these counties into contiguous chunks that have
# close to the target population for each district target pop approximately +/- 30%


# we can comment out some districts to make it a smaller problem to solve
# e.g. comment out the first three chunks to have it solve for just the first
# three districts. It limites the options and number of vairables to solve for

model += x['Lake County, TN', 1] == 1
model += x['Dyer County, TN', 1] == 1
model += x['Lauderdale County, TN', 1] == 1
model += x['Tipton County, TN', 1] == 1
model += x['Fayette County, TN', 1] == 1
model += x['Haywood County, TN', 1] == 1
model += x['Crockett County, TN', 1] == 1
model += x['Gibson County, TN', 1] == 1
model += x['Obion County, TN', 1] == 1
model += x['Weakley County, TN', 1] == 1
model += x['Henry County, TN', 1] == 1
model += x['Carroll County, TN', 1] == 1
model += x['Madison County, TN', 1] == 1
model += x['Hardeman County, TN', 1] == 1
model += x['McNairy County, TN', 1] == 1
model += x['Chester County, TN', 1] == 1
model += x['Henderson County, TN', 1] == 1
model += x['Hardin County, TN', 1] == 1
model += x['Decatur County, TN', 1] == 1
model += x['Benton County, TN', 1] == 1
model += x['Stewart County, TN', 1] == 1
model += x['Houston County, TN', 1] == 1
model += x['Humphreys County, TN', 1] == 1
model += x['Perry County, TN', 1] == 1
model += x['Wayne County, TN', 1] == 1
model += x['Lawrence County, TN', 1] == 1
model += x['Lewis County, TN', 1] == 1
model += x['Hickman County, TN', 1] == 1
model += x['Dickson County, TN', 1] == 1


model += x['Montgomery County, TN', 2] == 1
model += x['Cheatham County, TN', 2] == 1
model += x['Robertson County, TN', 2] == 1
model += x['Williamson County, TN', 2] == 1
model += x['Maury County, TN', 2] == 1
model += x['Giles County, TN', 2] == 1
model += x['Lincoln County, TN', 2] == 1
model += x['Marshall County, TN', 2] == 1



model += x['Sumner County, TN', 3] == 1
model += x['Wilson County, TN', 3] == 1
model += x['Rutherford County, TN', 3] == 1
model += x['Bedford County, TN', 3] == 1
model += x['Moore County, TN', 3] == 1
model += x['Franklin County, TN', 3] == 1


model += x['Coffee County, TN', 4] == 1
model += x['Cannon County, TN', 4] == 1
model += x['DeKalb County, TN', 4] == 1
model += x['Smith County, TN', 4] == 1
model += x['Trousdale County, TN', 4] == 1
model += x['Macon County, TN', 4] == 1
model += x['Clay County, TN', 4] == 1
model += x['Jackson County, TN', 4] == 1
model += x['Putnam County, TN', 4] == 1
model += x['White County, TN', 4] == 1
model += x['Warren County, TN', 4] == 1
model += x['Van Buren County, TN', 4] == 1
model += x['Grundy County, TN', 4] == 1
model += x['Marion County, TN', 4] == 1
model += x['Sequatchie County, TN', 4] == 1
model += x['Bledsoe County, TN', 4] == 1
model += x['Overton County, TN', 4] == 1
model += x['Pickett County, TN', 4] == 1
model += x['Hamilton County, TN', 4] == 1


model += x['Fentress County, TN', 5] == 1
model += x['Cumberland County, TN', 5] == 1
model += x['Rhea County, TN', 5] == 1
model += x['Morgan County, TN', 5] == 1
model += x['Meigs County, TN', 5] == 1
model += x['Bradley County, TN', 5] == 1
model += x['McMinn County, TN', 5] == 1
model += x['Polk County, TN', 5] == 1
model += x['Roane County, TN', 5] == 1
model += x['Scott County, TN', 5] == 1
model += x['Monroe County, TN', 5] == 1
model += x['Loudon County, TN', 5] == 1
model += x['Campbell County, TN', 5] == 1
model += x['Anderson County, TN', 5] == 1
model += x['Union County, TN', 5] == 1
model += x['Claiborne County, TN', 5] == 1

# model += x['Knox County, TN', 6] == 1
# model += x['Blount County, TN', 6] == 1
# model += x['Grainger County, TN', 6] == 1
# model += x['Jefferson County, TN', 6] == 1
# model += x['Sevier County, TN', 6] == 1

# model += x['Hancock County, TN', 7] == 1
# model += x['Hawkins County, TN', 7] == 1
# model += x['Hamblen County, TN', 7] == 1
# model += x['Cocke County, TN', 7] == 1
# model += x['Greene County, TN', 7] == 1
# model += x['Sullivan County, TN', 7] == 1
# model += x['Washington County, TN', 7] == 1
# model += x['Unicoi County, TN', 7] == 1
# model += x['Carter County, TN', 7] == 1
# model += x['Johnson County, TN', 7] == 1

################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################

# d6
model += x['Knox County, TN', 1] == 0
model += x['Knox County, TN', 2] == 0
model += x['Knox County, TN', 3] == 0
model += x['Knox County, TN', 4] == 0
model += x['Knox County, TN', 5] == 0

model += x['Blount County, TN', 1] == 0
model += x['Blount County, TN', 2] == 0
model += x['Blount County, TN', 3] == 0
model += x['Blount County, TN', 4] == 0
model += x['Blount County, TN', 5] == 0

model += x['Grainger County, TN', 1] == 0
model += x['Grainger County, TN', 2] == 0
model += x['Grainger County, TN', 3] == 0
model += x['Grainger County, TN', 4] == 0
model += x['Grainger County, TN', 5] == 0

model += x['Jefferson County, TN', 1] == 0
model += x['Jefferson County, TN', 2] == 0
model += x['Jefferson County, TN', 3] == 0
model += x['Jefferson County, TN', 4] == 0
model += x['Jefferson County, TN', 5] == 0

model += x['Sevier County, TN', 1] == 0
model += x['Sevier County, TN', 2] == 0
model += x['Sevier County, TN', 3] == 0
model += x['Sevier County, TN', 4] == 0
model += x['Sevier County, TN', 5] == 0

# d7
model += x['Hancock County, TN', 1] == 0
model += x['Hancock County, TN', 2] == 0
model += x['Hancock County, TN', 3] == 0
model += x['Hancock County, TN', 4] == 0
model += x['Hancock County, TN', 5] == 0

model += x['Hawkins County, TN', 1] == 0
model += x['Hawkins County, TN', 2] == 0
model += x['Hawkins County, TN', 3] == 0
model += x['Hawkins County, TN', 4] == 0
model += x['Hawkins County, TN', 5] == 0

model += x['Hamblen County, TN', 1] == 0
model += x['Hamblen County, TN', 2] == 0
model += x['Hamblen County, TN', 3] == 0
model += x['Hamblen County, TN', 4] == 0
model += x['Hamblen County, TN', 5] == 0

model += x['Cocke County, TN', 1] == 0
model += x['Cocke County, TN', 2] == 0
model += x['Cocke County, TN', 3] == 0
model += x['Cocke County, TN', 4] == 0
model += x['Cocke County, TN', 5] == 0

model += x['Greene County, TN', 1] == 0
model += x['Greene County, TN', 2] == 0
model += x['Greene County, TN', 3] == 0
model += x['Greene County, TN', 4] == 0
model += x['Greene County, TN', 5] == 0

model += x['Sullivan County, TN', 1] == 0
model += x['Sullivan County, TN', 2] == 0
model += x['Sullivan County, TN', 3] == 0
model += x['Sullivan County, TN', 4] == 0
model += x['Sullivan County, TN', 5] == 0

model += x['Washington County, TN', 1] == 0
model += x['Washington County, TN', 2] == 0
model += x['Washington County, TN', 3] == 0
model += x['Washington County, TN', 4] == 0
model += x['Washington County, TN', 5] == 0

model += x['Unicoi County, TN', 1] == 0
model += x['Unicoi County, TN', 2] == 0
model += x['Unicoi County, TN', 3] == 0
model += x['Unicoi County, TN', 4] == 0
model += x['Unicoi County, TN', 5] == 0

model += x['Carter County, TN', 1] == 0
model += x['Carter County, TN', 2] == 0
model += x['Carter County, TN', 3] == 0
model += x['Carter County, TN', 4] == 0
model += x['Carter County, TN', 5] == 0

model += x['Johnson County, TN', 1] == 0
model += x['Johnson County, TN', 2] == 0
model += x['Johnson County, TN', 3] == 0
model += x['Johnson County, TN', 4] == 0
model += x['Johnson County, TN', 5] == 0

len(county_list)

# Constraint 3: Adjacency
for j in district_list:
  for i in county_list:
    for (county, neighbors) in county_dict.items():
      if i == county:

          model += x[i, j] <= lpSum(x[neighbor, j] for neighbor in neighbors)

# constraint 4: ensure the Yijd variables = 1 only if both counties i and j are in the same district, d
# see notes on distance variables and constraints above



for (i, j) in pairs_list:
    #print(i, j)
    for d in district_list:
        model += y[i, j, d] <= x[i, d]
        #print(y[i, j, d])
        #print(x[i, d])

for (i, j) in pairs_list:
    for d in district_list:
        model += y[i, j, d] <= x[j, d]

for (i, j) in pairs_list:
    for d in district_list:
        model += y[i, j, d] >= (x[i, d] + x[j, d] - 1)

# Objective Function
### distance optimization - minimize the sum of distances between pairs of counties in each district


model += lpSum(y[i, j, d] * county_county_distance_dict[(i, j)] for (i, j) in pairs_list for d in district_list)

len(county_list)

# Solve
model.solve()

num_check = 0

# Output results
for j in district_list:
    assigned_counties = [i for i in county_list if x[i, j].varValue == 1]
    print(f"District {j}: {assigned_counties}")
    print(len(assigned_counties))
    num_check = num_check + len(assigned_counties)
    district_pop = 0
    for z in assigned_counties:
        district_pop += populations[z]
    print(f'Population: {district_pop}')
    print()


print("Total number of counties in the 7 districts: ", num_check)

district_pop = 0
pop_calc_list = [

'Meigs County, TN', 'Polk County, TN', 'Rhea County, TN', 'Roane County, TN', 'Blount County, TN', 'Loudon County, TN', 'Monroe County, TN', 'Bradley County, TN', 'Cumberland County, TN', 'McMinn County, TN'
]
for z in pop_calc_list:
    district_pop += populations[z]
print(district_pop)

